## 通俗的方式解释dfs
从一个结点出发，沿着一条路径走到底，走到底后回溯到上一个分支，然后再次走到底，重复这个过程。

如果换成代码的方式，就是从根结点出发，**递归**的访问每个子节点，直到没有子结点为止。当然也可以使用**栈**来模拟递归的实现。

## [路径总和](https://leetcode.cn/problems/path-sum/)
![dfs1](https://github.com/TanLian/algorithm/blob/main/img/dfs1.png)

```go
func hasPathSum(root *TreeNode, targetSum int) bool {
	// 边界情况处理
	if root == nil {
		return false
	}

	var dfs func(node *TreeNode, sum int) bool // 参数1是遍历到的当前结点，参数2是从根结点到该结点的路径和
	dfs = func(node *TreeNode, sum int) bool {
		// 递归终止条件：当前结点为nil
		if node == nil {
			return false
		}

		return dfs(node.Left, sum+node.Val) || dfs(node.Right, sum+node.Val)
	}
	return dfs(root, 0)
}
```
我们可以很快用**递归**写出上面的代码，这个也确实是深度优先搜索，但是这个代码是错误的，因为在上面的代码中，递归的终止条件是当前结点为nil。我们可以想象一下下面这个场景：

![dfs2](https://github.com/TanLian/algorithm/blob/main/img/dfs2.png)

如果递归终止为nil的话，那么就相当于**在叶子结点的下一层还有一层null结点**，我们会一直遍历到null结点为止，这就会遍历到一条路径 **1 -> null**，这条路径的总和为1，等于targetSum，所以返回true，而这条路径显然不符合题意，因为题目要求的是从根结点到叶子结点，所以上面这个解法是错误的。

**正确的递归结束条件为遍历到叶子结点为止**，golang代码如下：
```go
func hasPathSum(root *TreeNode, targetSum int) bool {
	// 边界情况处理
	if root == nil {
		return false
	}

	var dfs func(node *TreeNode, sum int) bool // 参数1是遍历到的当前结点，参数2是从根结点到该结点的路径和
	dfs = func(node *TreeNode, sum int) bool {
		// 递归终止条件：到达叶子结点
		if node.Left == nil && node.Right == nil {
			return sum+node.Val == targetSum
		}

		// 递归处理非叶子结点
		if node.Left != nil {
			if dfs(node.Left, sum+node.Val) {
				return true
			}
		}

		if node.Right != nil {
			if dfs(node.Right, sum+node.Val) {
				return true
			}
		}
		return false
	}
	return dfs(root, 0)
}
```
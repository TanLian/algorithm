单调栈

## 单调栈是什么？有什么特性

单调栈是一种特殊的**栈**型数据结构，特殊性在于栈内的元素保持**单调递增**（或**单调递减**）.

## 单调栈一般用来解决什么问题？

单调栈主要用来解决一类问题，即在一个数组中找到每个元素的左边（或右边）**第一个比它大（或小）的元素**，该问题也被称为**Next Greater Element**问题。

举个例子，如给定一个数组```[2, 1, 4, 3, 5]```，对于数组中每个元素而言，在该元素右侧查找，找到第一个大于该元素的值，如果找不到则填充-1，如对于2而言，右侧第一个大于2的值是4，对于5而言，找不到就填充-1，以数组的形式返回，如该例子就要返回```[4,4,5,5,-1]```

先思考一会儿。。。

                    5

                    分

                    钟

                    后

如果不用单调栈（或之前没学过单调栈），则最容易想到的办法就是暴力法，通过两层for循环来解决，代码如下：

```rust
impl Solution {
    pub fn find_greater_num(nums: Vec<i32>) -> Vec<i32> {
        let mut ret = vec![-1; nums.len()]; // ret是一个和nums长度相同的int32类型的数组，且数组的每个元素都初始化为-1
        for i in 0..nums.len() { // 依次遍历每个元素
            for j in i+1..nums.len() { // 依次遍历该元素右侧的每个元素
                if nums[j] > nums[i] { // 找到了比当前元素更大的元素
                    ret[i] = nums[j];
                    break; // 由于我们要找的是第一个，所以一旦找到了就break掉，不用继续找了
                }
            }
        }
        ret
    }
}
```

暴力法最容易想到，也是正确的，但是就是时间复杂度太高了，为O(N^2)，这样的代码如果提交到leetcode上大概率会报超出时间限制。

那么这个时候就要想了，有没有一种算法能够降低时间复杂度呢？最好能够降到O(N)。

这个时候就轮到单调栈出马了。单调栈的主要思想是维护一个单调递增（或递减）的栈。**遍历每一个元素的时候，将元素依次入栈，并且在入栈前先检查栈顶元素是否需要被弹出，直到栈顶元素满足单调性为止。注意这个元素（实际上是下标）是一定要push到栈顶的，当该元素被push进栈中时可能会破坏掉栈的单调性，所以为了保持单调性我们需要先把比该元素大（或小）的元素pop出来，在pop的过程中我们就找到了一个个答案。**

这么说可能有点抽象，我们还是以```[2,1,4,3,5]```这个数组为例，我们维护一个单调递减的栈，栈中存放的是元素下标，让我们来模拟每一步：

遍历到2：由于栈为空，所以我们直接把元素2的下标0 push到栈中，此时栈为```[0]```。

遍历到1：由于1比栈顶元素nums[0]小，所以把它push进栈时不会破坏栈的单调性，我们把元素1的下标1 push进栈中，此时栈为```[0,1]```。

遍历到4：由于4比栈顶元素nums[1]大，所以把它push进栈时会破坏栈的单调性，所以我们要先把比4小的元素pop出来，依次从栈中pop出1和0，我们就可以更新下标为1和0的答案了，即下标为1和0的答案都是4.翻译过来就是2的右侧第一个大于2的元素是4，1的右侧第一个大于1的元素也是4.然后把4的下标2 push进栈中，此时栈为```[2]```。

遍历到3：由于3比4小，不会破坏栈的单调性，直接把3的下标3 push进栈中，此时栈为```[2,3]```。

遍历到5：由于5比栈内元素都大，为了不破坏单调性需要先将栈中元素pop出来，依次pop出2和3（注意2和3是元素下标），然后更新下标为2和3的答案为5。pop完后将5的下标4 push进栈中，此时栈为```[4]```。

遍历完后，最终答案为```[4,4,5,5,-1]```

代码如下：

```rust
impl Solution {
    pub fn find_greater_num(nums: Vec<i32>) -> Vec<i32> {
        let mut ret = vec![-1; nums.len()]; // ret是一个和nums长度相同的int32类型的数组，且数组的每个元素都初始化为-1
        let mut stack: Vec<usize> = vec![]; // 用数组模拟栈，注意栈中存放的是元素下标而非元素值
        for i in 0..nums.len() { // 从左往右依次遍历每个元素
            while !stack.is_empty() && nums[*stack.last().unwrap()] < nums[i] { // 依次弹出栈中比当前元素小的元素
                let j = stack.pop().unwrap();
                ret[j] = nums[i];
            }
            stack.push(i);
        }
        ret
    }
}
```

首先需要明确的是，**栈中存放的是元素下标（即index）**，而非元素本身。知道这点是很重要的，我们可以通过下标获取到元素的值，反之则不行（除非用一个map把值与下标的对应关系存起来，不过这需要有个数组中各个元素都不相同的前提）。而且我们在pop的时候是需要根据下表来更新答案的，所以栈中存放的是元素下标。

然后需要解释下为什么本题要用单调递减的栈而不是单调递增的栈。我们可以用单调递增的栈来尝试下是否可以解决此题。

遍历到2：由于栈为空，我们直接将下标0push进栈中，此时栈为```[0]```

遍历到1：由于1比2小，所以会破坏栈的单调递增特性，所以需要先把栈顶元素pop出来，pop的时候我们会发现我们不能更新答案，因为我们要求的是右侧第一个大的元素，而1比2小所以不满足要求。

所以此题我们不能用单调递增栈。

## 什么时候该用单调递增的栈？什么时候该用单调递减的栈？

这个一般来说没有绝对要使用单调递增的栈或单调递减的栈，都是具体问题具体分析，只要知道用单调栈来解决这个问题就好。

一般来说：

如果要找该元素左/右侧第一个比他大的元素，用单调递减栈；

如果要找该元素左/右侧第一个比他小的元素，用单调递增栈；

通过利用单调栈的特性，我们可以在**O(n)时间复杂度**内解决许多与NGE或PGE相关的问题。除了上述例子中的找到每个数字右侧第一个比它大的数外，还有许多其他应用场景，例如找到每个数字左侧第一个比它大的数、找到每个数字左右两侧第一个比它大的数等等。

下一个更大元素：https://leetcode.cn/problems/next-greater-element-i/

下一个更大元素2：https://leetcode.cn/problems/next-greater-element-ii/description/
单调队列是一种特殊的队列，用于解决滑动窗口问题。什么是滑动窗口问题呢？我们可以将滑动窗口看做是一个固定大小的窗口，它在数据结构中沿着数据流“滑动”，每次移动一个单位，并且在这个范围内执行某些操作。比如，求区间最大值、求区间最小值等。

对于滑动窗口问题，常规的方法是使用两个for循环来遍历所有可能的子数组，并找到需要的信息。但是这种方法的时间复杂度为O(n^2)，效率较低。单调队列是一种可以优化滑动窗口问题的数据结构，可以将时间复杂度降到O(n)。

单调队列主要有两种类型：单调递增队列和单调递减队列。这里以单调递增队列为例说明。

单调递增队列的特点是：队列中元素按照从前到后的顺序排列，并且队头元素是整个队列中最小的元素。当我们向队列中添加新元素时，如果发现这个元素比队尾元素更小，那就把队尾元素弹出，直到队列中的元素依然保持单调递增的顺序。

在滑动窗口问题中，我们可以将一个固定大小的窗口看做是一个队列。当窗口向右移动时，我们需要把新的元素添加到队列中，并且可能需要弹出队列中一些不再窗口内的元素。这时候，我们就可以使用单调递增队列来维护队列中的元素。

例如，对于给定的数组arr和窗口大小k，我们可以定义一个双端队列q，用于存储窗口中的下标。则遍历整个数组时，滑动窗口的最大值为arr[q.front()]，其中q.front()表示队列头部元素的下标。具体的实现过程如下：

1. 首先将前k个元素的下标加入队列中
  
2. 从第k个元素开始循环遍历数组，依次执行以下步骤：
  
  a. 将当前元素的下标加入队列中
  
  b. 如果队列头部元素的下标已经不在窗口内，将其弹出队列
  
  c. 维护队列的单调性，即保证队列中元素下标对应的值单调递减
  
  d. 如果当前元素的下标与队列头部元素的下标之差大于等于k，将队列头部元素弹出队列
  
3. 返回所有滑动窗口的最大值
  

总之，单调队列是一种高效的数据结构，用于解决滑动窗口问题。它可以将时间复杂度降到O(n)，极大地提高了算法的效率。

滑动窗口最大值：https://leetcode.cn/problems/sliding-window-maximum/description/

这个题如果用暴力解的话时间复杂度为O(N^2)，会超时，我们可以使用一个双端队列来维护滑动窗口内的下标。对于每个元素，我们执行以下步骤：

1. 如果队列头部元素不在当前窗口内，将其弹出队列
  
2. 维护队列的单调性，即保证队列中元素对应的值单调递减
  
3. 将当前元素下标加入队列
  
4. 存储滑动窗口中的最大值
  

rust代码如下：

```rust
struct Solution;

use std::collections::VecDeque;
impl Solution {
    pub fn max_sliding_window(nums: Vec<i32>, k: i32) -> Vec<i32> {
        let mut result = Vec::new();  // 存储结果的数组
        let mut deque = VecDeque::new();  // 存储下标的双端队列

        for i in 0..nums.len() {
            // 如果队列头部元素不在当前窗口内，将其弹出队列
            if !deque.is_empty() && deque.front().unwrap() < &(i as i32 - k + 1) {
                deque.pop_front();
            }

            // 维护队列的单调性，即保证队列中元素对应的值单调递减
            while !deque.is_empty() && nums[*deque.back().unwrap() as usize] < nums[i] {
                deque.pop_back();
            }

            // 将当前元素下标加入队列
            deque.push_back(i as i32);

            // 存储滑动窗口中的最大值
            if i >= k as usize - 1 {
                result.push(nums[deque.front().unwrap().clone() as usize]);
            }
        }

        result
    }
}
```

跳跃游戏Vi：https://leetcode.cn/problems/jump-game-vi/description/

熟悉动态规划的同学都知道，这道题一看就可以用动态规划，因为可以找到规律，到达下标为i处的最大得分只与它的前k个位置有关，所以只要求出了前k个位置的最大得分也就求出了自己的最大得分，于是我们很容易写出以下动态规划代码：

```rust
impl Solution {
    pub fn max_result(nums: Vec<i32>, k: i32) -> i32 {
        if nums.len() == 1 {
            return nums[0];
        }

        let mut dp = vec![i32::MIN; nums.len()]; // dp[i]: 从下标0调到下标i处得到的最大得分
        dp[0] = nums[0];
        for i in 1..dp.len() {
            for j in 1..=(k as usize).min(i) {
                dp[i] = dp[i].max(dp[i-j] + nums[i]);
            }
        }
        dp[dp.len()-1]
    }
}
```

这个算法的时间复杂度为O(NK)，最坏情况下时间复杂度达到O(N2)，提交会超时。我们仔细想想就可以发现，下标i的前k个位置和下标i+1的前k个位置其实是有很多重复的，所以这里有很多重复的计算，我们可以用单调队列优化下第二层for循环，代码如下：

```rust
use std::collections::VecDeque;

fn max_result(nums: Vec<i32>, k: i32) -> i32 {
    let n = nums.len();
    let mut dp = vec![0_i32; n];
    let mut deque = VecDeque::new();
    dp[0] = nums[0];
    deque.push_back(0);

    for i in 1..n {
        // 如果队列头部元素不在当前窗口内，将其弹出队列
        if !deque.is_empty() && deque.front().unwrap() < &(i as i32 - k) {
            deque.pop_front();
        }

        // 计算从起点到位置i的最大得分
        dp[i] = dp[*deque.front().unwrap()] + nums[i];

        // 维护队列的单调性，即保证队列中元素对应的dp值单调递减
        while !deque.is_empty() && dp[i] >= dp[*deque.back().unwrap()] {
            deque.pop_back();
        }

        // 将当前位置下标加入队列
        deque.push_back(i);
    }
    dp[n-1]
}
```

在上面的代码中，我们使用一个dp数组来记录从起点到每个位置的最大得分。我们还使用一个单调递减队列来维护当前窗口内得分最大的位置。

对于每个位置i，我们执行以下步骤：

1. 如果队列头部元素不在当前窗口内，将其弹出队列
  
2. 计算从起点到位置i的最大得分，即dp[i] = dp[q[0]] + nums[i]
  
3. 维护队列的单调性，即保证队列中元素对应的dp值单调递减
  
4. 将当前位置下标加入队列